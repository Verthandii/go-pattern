# SOLID

SOLID 指的是五种原则，分别是**单一职责原则**、**开闭原则**、**里氏替换原则**、**接口隔离原则**以及**依赖倒置原则**。

所有良好的设计模式都应该满足这五种原则，当它们应用到一起时，会大大增加代码的扩展性、鲁棒性，甚至可读性。

## 单一职责原则（Single Responsibility Principle）

### 含义

每一个 **struct**、**interface** 或 **function** 只负责一件事。

### 优势

1. 代码量很少，可读性增强，更便于维护
2. 职责单一，便于与其他功能组合起来，更灵活

> 但事实上，struct 的单一职责在项目中是很难保证的，它通常是来做一类事情，而不是一件事。

## 开闭原则（Open Closed Principle）

### 含义

对扩展开放，对修改关闭。

### 优势

1. 极少的情况下会修改原先的代码，保证了项目的稳定
2. 可以无限扩展对于新类型的处理，扩展性较好

### 难点

需要我们能够用抽象构建架构，用实现扩展细节。抽象要合理，要对需求的变更有前瞻性和预见性。

## 里氏替换原则（Liskov Substitution Principle）

### 含义

所有引用基类的地方必须能透明地使用其子类的对象。

> golang 中的基类与子类通过内嵌的形式来形成
>
> ```golang
> // Base 基类
> type Base struct {}
> 
> // Son 子类
> type Son struct {
>     *Base
> }
> ```

### 优势

1. 子类从基类继承过来的方法在语义上是一致的，可读性更强

### 难点

尽量不重写基类的方法，如果需要重写的话，不能改变基类方法原先的主逻辑。

## 接口隔离原则（Interface Segregation Principle）

### 含义

1. 客户端不应该依赖它不需要的接口。
2. 大接口应该细分为几个小接口，类间的依赖关系应该建立在最小的接口上。

### 优势

1. 接口隔离减少了对外交互，提高了内聚性
2. 多个粒度小的接口可以提升灵活性和可维护性

### 难点

接口的粒度大小很难合理的定义。

如果定义太大，会造成实现类写冗余代码，更难和其他类进行交互，灵活性变差；如果太小的话，可能会出现大量的接口，导致代码结构更复杂，可读性、可维护性变差。

## 依赖倒置原则（Dependence Inversion Principle）

### 含义

1. 高层模块不应该依赖低层模块，它们（高层模块和低层模块）都应该依赖于抽象。
2. 抽象不应该依赖于具体，具体应该依赖于抽象。

> e.g. 奶茶店不应该依赖于具体的奶茶，奶茶店和具体的奶茶应该都依赖于奶茶这个抽象

### 优势

1. 低层模块修改之后，高层模块不需要改变，可维护性强
2. 高层模块独立于低层模块时，它们就能很简单地被复用了，扩展性强
